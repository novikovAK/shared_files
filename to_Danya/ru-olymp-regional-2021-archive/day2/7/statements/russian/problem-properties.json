{"scoring":"Кроме теста из примера в этой задаче $20$ тестов, каждый независимо оценивается в $5$ баллов. Среди этих тестов в пяти тестах $c = 2$ и в пятнадцати тестах $c = 3$.\r\n\r\nДля каждого теста сообщается результат проверки на этом тесте.","notes":"","legend":"Назовем раскраску клеток таблицы $n \\times m$ \\textit{хорошей}, если никакие четыре клетки, центры которых образуют вершины прямоугольника со сторонами, параллельными осям координат, не покрашены в один цвет.\r\n\r\nИначе говоря, для раскраски не должно быть четверки целых чисел $x_1, x_2, y_1, y_2$, что $1 \\leq x_1 < x_2 \\leq n$, $1 \\leq y_1 < y_2 \\leq m$, и клетки $(x_1, y_1)$, $(x_2, y_1)$, $(x_1, y_2)$ и $(x_2, y_2)$ покрашены в одинаковый цвет.\r\n\r\nТребуется написать программу, которая по заданным целым числам $n$, $m$ и $c$ находит любую хорошую раскраску таблицы $n \\times m$ в $c$ цветов. ","authorLogin":"gainullin.ildar","language":"russian","timeLimit":1000,"output":"Выведите $n$ строк по $m$ чисел в каждой. \r\n\r\nВ качестве $j$-го числа $i$-й строки выведите $a_{i,j}$ \"--- цвет клетки $(i,j)$ ($1 \\leq a_{i,j} \\leq c$).\r\n\r\nЕсли есть несколько хороших раскрасок, можно вывести любую из них.","inputFile":"stdin","outputFile":"stdout","input":"В первой строке записаны три целых числа $n, m, c$ ($2 \\leq n, m \\leq 10$, $2 \\leq c \\leq 3$).\r\n\r\nГарантируется, что для заданных во входных данных значений существует хотя бы одна хорошая раскраска.","authorName":"Ildar Gainullin","sampleTests":[{"output":"1 2 \r\n2 2 \r\n","input":"2 2 2\r\n","inputFile":"example.01","outputFile":"example.01.a"}],"name":"Хорошие раскраски","interaction":null,"memoryLimit":536870912,"tutorial":"\\medskip\r\n\\textit{Автор задачи: Ильдар Гайнуллин}\r\n\\medskip\r\n\r\nЭта задача \"--- довольно нетрадиционная для олимпиад по информатике. Вместо конкретного конструктивного или алгоритмического решения участникам предлагалось поэкспериментировать с эвристиками и перебором.\r\n\r\nПрежде чем разобрать основные идеи, отметим, что конструктивного решения в этой задаче, скорее всего, нет. На это наводит следующая мысль: конструктивный паттерн, который решал бы задачу для приведенных ограничений, мог бы быть распространен на бесконечное поле. А можно доказать \"--- кстати, интересное олимпиадное упражнение по математике \"--- что раскрасить таким образом в 2 или 3 цвета бесконечное поле невозможно.\r\n\r\nОтметим, что в задаче очень маленькие ограничения и потестовая оценка. В принципе, можно локально запустить решение для всех возможных входов (их 200) и отправить в систему результаты предподсчета. Практически любое продвижение для больших полей вознаграждается баллами.\r\n\r\nПерейдем теперь к рассмотрению основных идей переборных решений и решений с помощью локальных оптимизаций.\r\n\r\n\\subsection*{Перебор}\r\nСамое простое решение это перебор за $\\mathcal{O}(c^{n \\cdot m})$, можно перебирать все раскраски простой рекурсией: перебирать цвета клеток в порядке сортировки по строкам и при равенстве по столбцам, и проверять, подходит ли итоговое поле. Чтобы оптимизировать это решение, в процессе перебора подходящих раскрасок, можно проверять, что среди клеток, которым уже проставлены значения, нет плохих четверок. Это решение уже может пройти все тесты с $c=2$ и значительное число тестов с $c=3$. Чтобы еще больше оптимизировать решение, можно перебирать цвета для клеток в случайном порядке. \r\n\r\nДополнительная оптимизация, которая сильно ускоряет перебор, \"--- добавление <<\\textit{мемоизации}>>. А именно, давайте запоминать некоторую информацию про текущую раскраску, которая точно не приведет к ответу (так как такая же комбинация перебиралась ранее, и ответ найден не был). Например, можно хранить множество троек $(c, y_1, y_2)$, что среди уже покрашенных клеток найдется $x$, что $a_{r,y_1}=a_{r,y_2}=c$, и проверять, что такое множество не встречалось, когда мы начинаем красить первую клетку в определенной строке.\r\n\r\nПрошлое решение работает заметно лучше при $m<n$, в противном случае можно поменять местами $n$ и $m$ и транспонировать поле для ответа. С этими оптимизациями можно пройти почти все тесты.\r\n\r\n\\subsection*{Локальные оптимизации}\r\nДругим возможным решением является метод локальных оптимизаций.\r\n\r\nИсходно проставим каждой клетке случайный цвет $1 \\ldots c$. Затем будем выбирать случайную клетку и изменять ей цвет, если при этом уменьшиться \\textit{стоимость} поля.\r\n\r\nСтоимостью поля может быть почти любая функция, которая будет равна нулю для хороших полей. Например, за нее можно взять количество четверок $x_1, x_2, y_1, y_2$, что $1 \\leq x_1 < x_2 \\leq n$, $1 \\leq y_1 < y_2 \\leq m$, и клетки $(x_1, y_1)$, $(x_2, y_1)$, $(x_1, y_2)$ и $(x_2, y_2)$ покрашены в одинаковый цвет.\r\nКогда никакое изменение цвета не приведет к уменьшению ответа, можно завершить процесс.\r\n\r\nДля большинства случайных раскрасок стоимость в конечном итоге будет равна маленькому числу. А если с исходной раскраской <<\\textit{повезёт}>>, то стоимость будет равна нулю, и поле сойдется к хорошему полю.\r\nОтсюда выходит следующее решение: будем случайно генерировать исходные поля, запускать описанный ваше процесс, пока стоимость уменьшается, и проверять что в конце получился $0$. Если получился, то можно вывести ответ. Иначе, генерируем исходное поле заново.\r\n\r\nЭто решение способно пройти все тесты с ограничениями этой задачи меньше чем за секунду.\r\n"}